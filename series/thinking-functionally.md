---
layout: series_index
title: "The 'thinking functionally' series"
seriesIndexId: "Thinking functionally"
---

This series of posts will introduce you to the fundamentals of functional programming
-- what does it really mean to "program functionally", and how this approach differs from object oriented or imperative programming.

* [Thinking Functionally: Introduction](../posts/thinking-functionally-intro.md). A look at the basics of functional programming.
* [Mathematical functions](../posts/mathematical-functions.md). The impetus behind functional programming.
* [Function Values and Simple Values](../posts/function-values-and-simple-values.md). Binding not assignment.
* [How types work with functions](../posts/how-types-work-with-functions.md). Understanding the type notation.
* [Currying](../posts/currying.md). Breaking multi-parameter functions into smaller one-parameter functions.
* [Partial application](../posts/partial-application.md). Baking-in some of the parameters of a function.
* [Function associativity and composition](../posts/function-composition.md). Building new functions from existing ones.
* [Defining functions](../posts/defining-functions.md). Lambdas and more.
* [Function signatures](../posts/function-signatures.md). A function signature can give you some idea of what it does.
* [Organizing functions](../posts/organizing-functions.md). Nested functions and modules.
* [Attaching functions to types](../posts/type-extensions.md). Creating methods the F# way.
* [Worked example: A stack based calculator](../posts/stack-based-calculator.md). Using combinators to build functionality.
